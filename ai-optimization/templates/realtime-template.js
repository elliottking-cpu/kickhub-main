#!/usr/bin/env node

/**
 * AI Real-time Template Generator
 * Generates real-time subscription templates and code snippets
 * Based on KickHub Build Guide Step 3.4 specifications (Lines 5584-5599)
 */

const fs = require('fs')
const path = require('path')

class RealtimeTemplateGenerator {
  constructor() {
    this.templates = new Map()
    this.setupTemplates()
  }

  setupTemplates() {
    // Database Migration Template
    this.templates.set('database-migration', {
      name: 'Real-time Database Migration',
      description: 'SQL migration to enable real-time on critical tables',
      template: `-- Migration: Enable Real-time Subscriptions
-- Auto-generated by AI Template Generator

BEGIN;

-- Enable real-time on critical tables
ALTER PUBLICATION supabase_realtime ADD TABLE {{TABLE_NAME}};

-- Add performance index
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_{{TABLE_NAME}}_realtime 
    ON {{TABLE_NAME}} ({{INDEX_COLUMNS}});

COMMIT;`
    })

    // RealtimeManager Subscription Template
    this.templates.set('realtime-subscription', {
      name: 'Real-time Subscription Method',
      description: 'Template for creating real-time subscription methods',
      template: `/**
 * Subscribe to {{SUBSCRIPTION_TYPE}} for {{ENTITY_TYPE}}
 * Handles real-time {{DATA_TYPE}} updates
 */
subscribe{{PASCAL_CASE_NAME}}({{PARAMS}}, callback: (payload: RealtimePayload) => void): RealtimeChannel {
  const channelName = \`{{CHANNEL_PREFIX}}-\${{{ENTITY_ID}}}\`
  
  if (this.channels.has(channelName)) {
    return this.channels.get(channelName)!
  }

  const channel = this.supabase
    .channel(channelName)
    .on(
      'postgres_changes',
      {
        event: '{{EVENTS}}',
        schema: 'public',
        table: '{{TABLE_NAME}}',
        filter: \`{{FILTER_COLUMN}}=eq.\${{{ENTITY_ID}}}\`
      },
      (payload) => {
        console.log('{{SUBSCRIPTION_TYPE}} update:', payload)
        callback({
          type: '{{PAYLOAD_TYPE}}',
          event: payload.eventType as 'INSERT' | 'UPDATE' | 'DELETE',
          data: payload.new || payload.old,
          timestamp: new Date()
        })
      }
    )
    .subscribe((status) => {
      console.log(\`\${channelName} status:\`, status)
      if (status === 'SUBSCRIBED') {
        this.connectionStatus = 'connected'
      }
    })

  this.channels.set(channelName, channel)
  return channel
}`
    })

    // React Hook Template
    this.templates.set('react-hook', {
      name: 'Real-time React Hook',
      description: 'Template for creating real-time React hooks',
      template: `/**
 * Hook for {{HOOK_DESCRIPTION}}
 * {{HOOK_DETAILS}}
 */
export function {{HOOK_NAME}}({{HOOK_PARAMS}}) {
  const { realtimeManager } = useRealtime()
  const [{{STATE_VAR}}, set{{PASCAL_STATE}}] = useState<{{STATE_TYPE}}>({{INITIAL_STATE}})
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    if (!{{DEPENDENCY_CHECK}}) {
      setIsLoading(false)
      return
    }

    setIsLoading(true)

    const handleUpdate = (payload: RealtimePayload) => {
      switch (payload.type) {
        case '{{UPDATE_TYPE}}':
          set{{PASCAL_STATE}}({{UPDATE_LOGIC}})
          break
      }
    }

    const channel = realtimeManager.{{SUBSCRIPTION_METHOD}}({{SUBSCRIPTION_PARAMS}}, handleUpdate)
    setIsLoading(false)

    return () => {
      realtimeManager.unsubscribeFromChannel(\`{{CHANNEL_NAME}}\`)
    }
  }, [{{DEPENDENCIES}}, realtimeManager])

  return { 
    {{STATE_VAR}}, 
    isLoading,
    {{ADDITIONAL_RETURNS}}
  }
}`
    })

    // Component Template
    this.templates.set('realtime-component', {
      name: 'Real-time Component',
      description: 'Template for components that use real-time data',
      template: `/**
 * {{COMPONENT_NAME}} - {{COMPONENT_DESCRIPTION}}
 * Uses real-time subscriptions for {{REALTIME_FEATURE}}
 */

import React from 'react'
import { {{HOOK_IMPORTS}} } from '@/hooks/useRealtime'

interface {{COMPONENT_NAME}}Props {
  {{PROP_DEFINITIONS}}
}

export function {{COMPONENT_NAME}}({ {{PROPS}} }: {{COMPONENT_NAME}}Props) {
  const { {{HOOK_DESTRUCTURING}} } = {{HOOK_USAGE}}

  if (isLoading) {
    return (
      <div className="animate-pulse">
        <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
        <div className="h-4 bg-gray-200 rounded w-1/2"></div>
      </div>
    )
  }

  return (
    <div className="{{COMPONENT_CLASSES}}">
      {{COMPONENT_CONTENT}}
    </div>
  )
}`
    })

    // Configuration Template
    this.templates.set('realtime-config', {
      name: 'Real-time Configuration',
      description: 'Template for real-time configuration sections',
      template: `{
  "{{CONFIG_SECTION}}": {
    "enabled": true,
    "provider": "supabase",
    "tables": {
      "{{TABLE_NAME}}": {
        "enabled": true,
        "events": [{{EVENTS}}],
        "filters": [{{FILTERS}}]
      }
    },
    "features": {
      {{FEATURES}}
    },
    "performance": {
      "max_reconnect_attempts": {{MAX_RECONNECTS}},
      "reconnect_delay": {{RECONNECT_DELAY}},
      "heartbeat_interval": {{HEARTBEAT_INTERVAL}},
      "connection_timeout": {{CONNECTION_TIMEOUT}}
    }
  }
}`
    })

    // Test Template
    this.templates.set('realtime-test', {
      name: 'Real-time Test Suite',
      description: 'Template for testing real-time functionality',
      template: `/**
 * {{TEST_NAME}} Test Suite
 * Tests for {{COMPONENT_NAME}} real-time functionality
 */

import { render, screen, waitFor } from '@testing-library/react'
import { {{COMPONENT_NAME}} } from '../{{COMPONENT_NAME}}'

// Mock real-time hooks
jest.mock('@/hooks/useRealtime', () => ({
  {{HOOK_NAME}}: jest.fn(() => ({
    {{MOCK_RETURN_VALUES}}
  }))
}))

describe('{{COMPONENT_NAME}}', () => {
  it('should {{TEST_DESCRIPTION}}', async () => {
    render(<{{COMPONENT_NAME}} {{TEST_PROPS}} />)
    
    // Test implementation
    {{TEST_ASSERTIONS}}
  })

  it('should handle real-time updates', async () => {
    const mockCallback = jest.fn()
    // Test real-time update handling
    {{REALTIME_TEST_LOGIC}}
  })

  it('should handle connection errors gracefully', async () => {
    // Test error handling
    {{ERROR_TEST_LOGIC}}
  })
})`
    })
  }

  /**
   * Generate code from template
   */
  generateFromTemplate(templateName, replacements = {}) {
    const template = this.templates.get(templateName)
    if (!template) {
      throw new Error(`Template '${templateName}' not found`)
    }

    let code = template.template
    
    // Replace all placeholders
    Object.entries(replacements).forEach(([key, value]) => {
      const placeholder = `{{${key}}}`
      code = code.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), value)
    })

    return {
      name: template.name,
      description: template.description,
      code
    }
  }

  /**
   * Generate real-time subscription method
   */
  generateSubscriptionMethod(config) {
    return this.generateFromTemplate('realtime-subscription', {
      SUBSCRIPTION_TYPE: config.subscriptionType || 'live updates',
      ENTITY_TYPE: config.entityType || 'entity',
      DATA_TYPE: config.dataType || 'data',
      PASCAL_CASE_NAME: config.pascalCaseName || 'EntityUpdates',
      PARAMS: config.params || 'entityId: string',
      ENTITY_ID: config.entityId || 'entityId',
      CHANNEL_PREFIX: config.channelPrefix || 'entity',
      EVENTS: config.events || '*',
      TABLE_NAME: config.tableName || 'entities',
      FILTER_COLUMN: config.filterColumn || 'id',
      PAYLOAD_TYPE: config.payloadType || 'entity_update'
    })
  }

  /**
   * Generate React hook
   */
  generateReactHook(config) {
    return this.generateFromTemplate('react-hook', {
      HOOK_NAME: config.hookName || 'useEntityUpdates',
      HOOK_DESCRIPTION: config.hookDescription || 'entity updates',
      HOOK_DETAILS: config.hookDetails || 'Subscribes to real-time entity data',
      HOOK_PARAMS: config.hookParams || 'entityId: string | null',
      STATE_VAR: config.stateVar || 'entityData',
      PASCAL_STATE: config.pascalState || 'EntityData',
      STATE_TYPE: config.stateType || 'any',
      INITIAL_STATE: config.initialState || 'null',
      DEPENDENCY_CHECK: config.dependencyCheck || 'entityId',
      UPDATE_TYPE: config.updateType || 'entity_update',
      UPDATE_LOGIC: config.updateLogic || 'payload.data',
      SUBSCRIPTION_METHOD: config.subscriptionMethod || 'subscribeToEntityUpdates',
      SUBSCRIPTION_PARAMS: config.subscriptionParams || 'entityId',
      CHANNEL_NAME: config.channelName || '${entityId}',
      DEPENDENCIES: config.dependencies || 'entityId',
      ADDITIONAL_RETURNS: config.additionalReturns || 'isSubscribed: !!entityId && !isLoading'
    })
  }

  /**
   * List available templates
   */
  listTemplates() {
    console.log('ðŸ“‹ Available Real-time Templates:')
    console.log('==================================')
    
    this.templates.forEach((template, name) => {
      console.log(`ðŸ”§ ${name}: ${template.description}`)
    })
  }

  /**
   * Save generated code to file
   */
  saveToFile(filePath, content) {
    const dir = path.dirname(filePath)
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }
    
    fs.writeFileSync(filePath, content, 'utf8')
    console.log(`âœ… Generated: ${filePath}`)
  }

  /**
   * Generate complete real-time setup
   */
  generateCompleteSetup(config = {}) {
    console.log('ðŸš€ Generating Complete Real-time Setup...')
    
    const outputs = []

    // Generate subscription method
    const subscription = this.generateSubscriptionMethod({
      subscriptionType: 'match updates',
      entityType: 'matches',
      dataType: 'match statistics',
      pascalCaseName: 'MatchUpdates',
      params: 'matchId: string',
      entityId: 'matchId',
      channelPrefix: 'match',
      events: '*',
      tableName: 'matches',
      filterColumn: 'id',
      payloadType: 'match_update'
    })
    outputs.push(subscription)

    // Generate React hook
    const hook = this.generateReactHook({
      hookName: 'useMatchUpdates',
      hookDescription: 'live match updates',
      hookDetails: 'Subscribes to real-time match data and statistics',
      hookParams: 'matchId: string | null',
      stateVar: 'matchData',
      pascalState: 'MatchData',
      stateType: 'any',
      initialState: 'null',
      dependencyCheck: 'matchId',
      updateType: 'match_update',
      updateLogic: 'payload.data',
      subscriptionMethod: 'subscribeToMatchUpdates',
      subscriptionParams: 'matchId',
      channelName: 'match-${matchId}',
      dependencies: 'matchId',
      additionalReturns: 'isSubscribed: !!matchId && !isLoading'
    })
    outputs.push(hook)

    return outputs
  }
}

// CLI interface
if (require.main === module) {
  const generator = new RealtimeTemplateGenerator()
  const command = process.argv[2]
  
  switch (command) {
    case 'list':
      generator.listTemplates()
      break
      
    case 'generate':
      const outputs = generator.generateCompleteSetup()
      outputs.forEach((output, index) => {
        console.log(`\nðŸ“„ Generated ${output.name}:`)
        console.log('=' .repeat(50))
        console.log(output.code)
      })
      break
      
    default:
      console.log('ðŸ“‹ Usage:')
      console.log('  node realtime-template.js list     - List available templates')
      console.log('  node realtime-template.js generate - Generate complete setup')
  }
}

module.exports = RealtimeTemplateGenerator

